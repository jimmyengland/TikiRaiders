import fs from "fs";
async function createRedirects(config, routes, dir, entryFile, type) {
  const _redirectsURL = new URL("./_redirects", dir);
  const kind = type ?? "functions";
  const definitions = [];
  for (const route of routes) {
    if (route.pathname) {
      if (route.distURL) {
        definitions.push({
          dynamic: false,
          input: route.pathname,
          target: prependForwardSlash(route.distURL.toString().replace(dir.toString(), "")),
          status: 200,
          weight: 1
        });
      } else {
        definitions.push({
          dynamic: false,
          input: route.pathname,
          target: `/.netlify/${kind}/${entryFile}`,
          status: 200,
          weight: 1
        });
        if (route.route === "/404") {
          definitions.push({
            dynamic: true,
            input: "/*",
            target: `/.netlify/${kind}/${entryFile}`,
            status: 404,
            weight: 0
          });
        }
      }
    } else {
      const pattern = "/" + route.segments.map(([part]) => {
        if (part.dynamic) {
          if (part.spread) {
            return "*";
          } else {
            return ":" + part.content;
          }
        } else {
          return part.content;
        }
      }).join("/");
      if (route.distURL) {
        const target = `${pattern}` + (config.build.format === "directory" ? "/index.html" : ".html");
        definitions.push({
          dynamic: true,
          input: pattern,
          target,
          status: 200,
          weight: 1
        });
      } else {
        definitions.push({
          dynamic: true,
          input: pattern,
          target: `/.netlify/${kind}/${entryFile}`,
          status: 200,
          weight: 1
        });
      }
    }
  }
  let _redirects = prettify(definitions);
  await fs.promises.appendFile(_redirectsURL, _redirects, "utf-8");
}
function prettify(definitions) {
  let minInputLength = 0, minTargetLength = 0;
  definitions.sort((a, b) => {
    if (a.input.length > minInputLength) {
      minInputLength = a.input.length;
    }
    if (b.input.length > minInputLength) {
      minInputLength = b.input.length;
    }
    if (a.target.length > minTargetLength) {
      minTargetLength = a.target.length;
    }
    if (b.target.length > minTargetLength) {
      minTargetLength = b.target.length;
    }
    return b.weight - a.weight;
  });
  let _redirects = "";
  definitions.forEach((defn, i) => {
    let inputSpaces = minInputLength - defn.input.length + 4;
    let targetSpaces = minTargetLength - defn.target.length + 4;
    _redirects += (i === 0 ? "" : "\n") + defn.input + " ".repeat(inputSpaces) + defn.target + " ".repeat(Math.abs(targetSpaces)) + defn.status;
  });
  return _redirects;
}
function prependForwardSlash(str) {
  return str[0] === "/" ? str : "/" + str;
}
export {
  createRedirects
};
