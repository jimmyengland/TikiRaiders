var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import { nestLists, isPortableTextToolkitList, isPortableTextListItemBlock, isPortableTextToolkitSpan, spanToPlainText, isPortableTextBlock, isPortableTextToolkitTextNode, buildMarksTree } from "@portabletext/toolkit";
const allowedProtocols = ["http", "https", "mailto", "tel"];
const charMap = {
  "&": "amp",
  "<": "lt",
  ">": "gt",
  '"': "quot",
  "'": "#x27"
};
function escapeHTML(str) {
  return str.replace(/[&<>"']/g, (s) => `&${charMap[s]};`);
}
function uriLooksSafe(uri) {
  const url = (uri || "").trim();
  const first = url.charAt(0);
  if (first === "#" || first === "/") {
    return true;
  }
  const colonIndex = url.indexOf(":");
  if (colonIndex === -1) {
    return true;
  }
  const proto = url.slice(0, colonIndex).toLowerCase();
  if (allowedProtocols.indexOf(proto) !== -1) {
    return true;
  }
  const queryIndex = url.indexOf("?");
  if (queryIndex !== -1 && colonIndex > queryIndex) {
    return true;
  }
  const hashIndex = url.indexOf("#");
  if (hashIndex !== -1 && colonIndex > hashIndex) {
    return true;
  }
  return false;
}
const link = ({ children, value }) => {
  const href = (value == null ? void 0 : value.href) || "";
  const looksSafe = uriLooksSafe(href);
  return looksSafe ? `<a href="${escapeHTML(href)}">${children}</a>` : children;
};
const defaultMarks = {
  em: ({ children }) => `<em>${children}</em>`,
  strong: ({ children }) => `<strong>${children}</strong>`,
  code: ({ children }) => `<code>${children}</code>`,
  underline: ({ children }) => `<span style="text-decoration:underline">${children}</span>`,
  "strike-through": ({ children }) => `<del>${children}</del>`,
  link
};
const defaultLists = {
  number: ({ children }) => `<ol>${children}</ol>`,
  bullet: ({ children }) => `<ul>${children}</ul>`
};
const DefaultListItem = ({ children }) => `<li>${children}</li>`;
const getTemplate = (type, prop) => `Unknown ${type}, specify a component for it in the \`components.${prop}\` option`;
const unknownTypeWarning = (typeName) => getTemplate(`block type "${typeName}"`, "types");
const unknownMarkWarning = (markType) => getTemplate(`mark type "${markType}"`, "marks");
const unknownBlockStyleWarning = (blockStyle) => getTemplate(`block style "${blockStyle}"`, "block");
const unknownListStyleWarning = (listStyle) => getTemplate(`list style "${listStyle}"`, "list");
const unknownListItemStyleWarning = (listStyle) => getTemplate(`list item style "${listStyle}"`, "listItem");
function printWarning(message) {
  console.warn(message);
}
const DefaultUnknownType = ({
  value,
  isInline
}) => {
  const warning = unknownTypeWarning(value._type);
  return isInline ? `<span style="display:none">${warning}</span>` : `<div style="display:none">${warning}</div>`;
};
const DefaultUnknownMark = ({
  markType,
  children
}) => {
  return `<span class="unknown__pt__mark__${markType}">${children}</span>`;
};
const DefaultUnknownBlockStyle = ({
  children
}) => {
  return `<p>${children}</p>`;
};
const DefaultUnknownList = ({ children }) => {
  return `<ul>${children}</ul>`;
};
const DefaultUnknownListItem = ({
  children
}) => {
  return `<li>${children}</li>`;
};
const DefaultHardBreak = () => "<br/>";
const defaultPortableTextBlockStyles = {
  normal: ({ children }) => `<p>${children}</p>`,
  blockquote: ({ children }) => `<blockquote>${children}</blockquote>`,
  h1: ({ children }) => `<h1>${children}</h1>`,
  h2: ({ children }) => `<h2>${children}</h2>`,
  h3: ({ children }) => `<h3>${children}</h3>`,
  h4: ({ children }) => `<h4>${children}</h4>`,
  h5: ({ children }) => `<h5>${children}</h5>`,
  h6: ({ children }) => `<h6>${children}</h6>`
};
const defaultComponents = {
  types: {},
  block: defaultPortableTextBlockStyles,
  marks: defaultMarks,
  list: defaultLists,
  listItem: DefaultListItem,
  hardBreak: DefaultHardBreak,
  unknownType: DefaultUnknownType,
  unknownMark: DefaultUnknownMark,
  unknownList: DefaultUnknownList,
  unknownListItem: DefaultUnknownListItem,
  unknownBlockStyle: DefaultUnknownBlockStyle
};
function mergeComponents(parent, overrides) {
  const _a = overrides, { block, list, listItem, marks, types } = _a, rest = __objRest(_a, ["block", "list", "listItem", "marks", "types"]);
  return __spreadValues(__spreadProps(__spreadValues({}, parent), {
    block: mergeDeeply(parent, overrides, "block"),
    list: mergeDeeply(parent, overrides, "list"),
    listItem: mergeDeeply(parent, overrides, "listItem"),
    marks: mergeDeeply(parent, overrides, "marks"),
    types: mergeDeeply(parent, overrides, "types")
  }), rest);
}
function mergeDeeply(parent, overrides, key) {
  const override = overrides[key];
  const parentVal = parent[key];
  if (typeof override === "function") {
    return override;
  }
  if (override && typeof parentVal === "function") {
    return override;
  }
  if (override) {
    return __spreadValues(__spreadValues({}, parentVal), override);
  }
  return parentVal;
}
function toHTML(value, options = {}) {
  const {
    components: componentOverrides,
    onMissingComponent: missingComponentHandler = printWarning
  } = options;
  const handleMissingComponent = missingComponentHandler || noop;
  const blocks = Array.isArray(value) ? value : [value];
  const nested = nestLists(blocks, "html");
  const components = componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents;
  const renderNode = getNodeRenderer(components, handleMissingComponent);
  const rendered = nested.map((node, index) => renderNode({ node, index, isInline: false, renderNode }));
  return rendered.join("");
}
const getNodeRenderer = (components, handleMissingComponent) => {
  function renderNode(options) {
    const { node, index, isInline } = options;
    if (isPortableTextToolkitList(node)) {
      return renderList(node, index);
    }
    if (isPortableTextListItemBlock(node)) {
      return renderListItem(node, index);
    }
    if (isPortableTextToolkitSpan(node)) {
      return renderSpan(node);
    }
    if (isPortableTextBlock(node)) {
      return renderBlock(node, index, isInline);
    }
    if (isPortableTextToolkitTextNode(node)) {
      return renderText(node);
    }
    return renderCustomBlock(node, index, isInline);
  }
  function renderListItem(node, index) {
    const tree = serializeBlock({ node, index, isInline: false, renderNode });
    const renderer = components.listItem;
    const handler = typeof renderer === "function" ? renderer : renderer[node.listItem];
    const itemHandler = handler || components.unknownListItem;
    if (itemHandler === components.unknownListItem) {
      const style = node.listItem || "bullet";
      handleMissingComponent(unknownListItemStyleWarning(style), {
        type: style,
        nodeType: "listItemStyle"
      });
    }
    let children = tree.children;
    if (node.style && node.style !== "normal") {
      const _a = node, { listItem } = _a, blockNode = __objRest(_a, ["listItem"]);
      children = renderNode({ node: blockNode, index, isInline: false, renderNode });
    }
    return itemHandler({ value: node, index, isInline: false, renderNode, children });
  }
  function renderList(node, index) {
    const children = node.children.map((child, childIndex) => renderNode({
      node: child._key ? child : __spreadProps(__spreadValues({}, child), { _key: `li-${index}-${childIndex}` }),
      index,
      isInline: false,
      renderNode
    }));
    const component = components.list;
    const handler = typeof component === "function" ? component : component[node.listItem];
    const list = handler || components.unknownList;
    if (list === components.unknownList) {
      const style = node.listItem || "bullet";
      handleMissingComponent(unknownListStyleWarning(style), { nodeType: "listStyle", type: style });
    }
    return list({ value: node, index, isInline: false, renderNode, children: children.join("") });
  }
  function renderSpan(node) {
    const { markDef, markType, markKey } = node;
    const span = components.marks[markType] || components.unknownMark;
    const children = node.children.map((child, childIndex) => renderNode({ node: child, index: childIndex, isInline: true, renderNode }));
    if (span === components.unknownMark) {
      handleMissingComponent(unknownMarkWarning(markType), { nodeType: "mark", type: markType });
    }
    return span({
      text: spanToPlainText(node),
      value: markDef,
      markType,
      markKey,
      renderNode,
      children: children.join("")
    });
  }
  function renderBlock(node, index, isInline) {
    const _a = serializeBlock({ node, index, isInline, renderNode }), { _key } = _a, props = __objRest(_a, ["_key"]);
    const style = props.node.style || "normal";
    const handler = typeof components.block === "function" ? components.block : components.block[style];
    const block = handler || components.unknownBlockStyle;
    if (block === components.unknownBlockStyle) {
      handleMissingComponent(unknownBlockStyleWarning(style), {
        nodeType: "blockStyle",
        type: style
      });
    }
    return block(__spreadProps(__spreadValues({}, props), { value: props.node, renderNode }));
  }
  function renderText(node) {
    if (node.text === "\n") {
      const hardBreak = components.hardBreak;
      return hardBreak ? hardBreak() : "\n";
    }
    return escapeHTML(node.text);
  }
  function renderCustomBlock(value, index, isInline) {
    const node = components.types[value._type];
    if (!node) {
      handleMissingComponent(unknownTypeWarning(value._type), {
        nodeType: "block",
        type: value._type
      });
    }
    const component = node || components.unknownType;
    return component({
      value,
      isInline,
      index,
      renderNode
    });
  }
  return renderNode;
};
function serializeBlock(options) {
  const { node, index, isInline, renderNode } = options;
  const tree = buildMarksTree(node);
  const children = tree.map((child, i) => renderNode({ node: child, isInline: true, index: i, renderNode }));
  return {
    _key: node._key || `block-${index}`,
    children: children.join(""),
    index,
    isInline,
    node
  };
}
function noop() {
}
export { defaultComponents, escapeHTML, mergeComponents, toHTML, uriLooksSafe };
//# sourceMappingURL=to-html.mjs.map
